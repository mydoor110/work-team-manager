{% extends "base.html" %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-3">
  <div>
    <h5 class="mb-0">åŸ¹è®­ç»Ÿè®¡åˆ†æ <span id="pageDateRange" class="badge bg-primary" style="font-size: 0.7em; vertical-align: middle;"></span></h5>
    <small class="text-muted">å¯è§†åŒ–åˆ†æåŸ¹è®­æ•°æ®å’Œé—®é¢˜è¶‹åŠ¿</small>
  </div>
  <div class="btn-group">
    <a href="{{ url_for('training.index') }}" class="btn btn-outline-secondary btn-sm">è¿”å›å·¥ä½œå°</a>
    <a href="{{ url_for('training.records') }}" class="btn btn-secondary btn-sm">æŸ¥çœ‹è®°å½•</a>
  </div>
</div>

<!-- ç­›é€‰åŒºåŸŸ -->
<div class="card shadow-sm mb-4">
  <div class="card-body">
    <div class="row g-3 align-items-end">
      <div class="col-md-2">
        <label for="nameFilter" class="form-label">å§“å</label>
        <input type="text" id="nameFilter" class="form-control form-control-sm">
      </div>
      <div class="col-md-2">
        <label for="startDate" class="form-label">å¼€å§‹æ—¥æœŸ</label>
        <input type="date" id="startDate" class="form-control form-control-sm">
      </div>
      <div class="col-md-2">
        <label for="endDate" class="form-label">ç»“æŸæ—¥æœŸ</label>
        <input type="date" id="endDate" class="form-control form-control-sm">
      </div>
      <div class="col-md-2">
        <label for="qualifiedFilter" class="form-label">æ˜¯å¦åˆæ ¼</label>
        <select id="qualifiedFilter" class="form-select form-select-sm">
          <option value="">å…¨éƒ¨</option>
          <option value="1">åˆæ ¼</option>
          <option value="0">ä¸åˆæ ¼</option>
        </select>
      </div>
      <div class="col-md-2">
        <button id="filterBtn" class="btn btn-sm btn-primary w-100">
          <i class="bi bi-search"></i> æŸ¥è¯¢
        </button>
      </div>
      <div class="col-md-2">
        <button id="resetBtn" class="btn btn-sm btn-outline-secondary w-100">
          <i class="bi bi-arrow-counterclockwise"></i> é‡ç½®ä¸ºæœ¬æœˆ
        </button>
      </div>
    </div>
  </div>
</div>

<!-- KPI å¡ç‰‡ -->
<div class="row g-4 mb-4">
  <div class="col-md-6">
    <div class="card shadow-sm">
      <div class="card-body text-center">
        <h6 class="card-subtitle mb-2 text-muted">ç­›é€‰åŒºé—´å†…æ€»äººæ¬¡</h6>
        <p class="card-text fs-1 fw-bold" id="kpi-total-count">0</p>
      </div>
    </div>
  </div>
  <div class="col-md-6">
    <div class="card shadow-sm">
      <div class="card-body text-center">
        <h6 class="card-subtitle mb-2 text-muted">ç­›é€‰åŒºé—´å†…å¤±æ ¼äººæ¬¡</h6>
        <p class="card-text fs-1 fw-bold text-danger" id="kpi-disqualified-count">0</p>
      </div>
    </div>
  </div>
</div>

<!-- ECharts å›¾è¡¨å®¹å™¨ -->
<div class="row g-4 mb-4">
  <div class="col-xl-8 col-lg-12">
    <div class="card shadow-sm h-100">
      <div class="card-body">
        <div id="personCountChart" style="width: 100%; min-height: 400px; height: 50vh; max-height: 600px;"></div>
      </div>
    </div>
  </div>
  <div class="col-xl-4 col-lg-6 col-md-12">
    <div class="card shadow-sm h-100">
      <div class="card-body">
        <div id="problemTypeChart" style="width: 100%; min-height: 350px; height: 50vh; max-height: 600px;"></div>
      </div>
    </div>
  </div>
  <div class="col-12">
    <div class="card shadow-sm">
      <div class="card-body">
        <div id="projectDisqualifiedChart" style="width: 100%; min-height: 400px; height: 55vh; max-height: 700px;"></div>
      </div>
    </div>
  </div>
</div>

<!-- New Row for Word Cloud and Team Rank -->
<div class="row g-4 mb-4">
  <div class="col-xl-8 col-lg-12">
    <div class="card shadow-sm h-100">
      <div class="card-body">
        <div id="wordCloudChart" style="width: 100%; min-height: 300px; height: 45vh; max-height: 500px;"></div>
      </div>
    </div>
  </div>
  <div class="col-xl-4 col-lg-12">
    <div class="card shadow-sm h-100">
      <div class="card-body">
        <h6 class="card-title text-center mb-3">ç­ç»„/è½¦é˜ŸPKæ¦œ</h6>
        <div id="teamRankList" style="max-height: 450px; overflow-y: auto; -webkit-overflow-scrolling: touch;">
          <!-- Ranking will be generated by JS -->
        </div>
      </div>
    </div>
  </div>
</div>

<!-- New Row for Key Personnel Trend -->
<div class="row g-4 mb-4">
  <div class="col-12">
    <div class="card shadow-sm">
      <div class="card-body">
        <div id="keyPersonnelTrendChart" style="width: 100%; min-height: 400px; height: 50vh; max-height: 600px;"></div>
      </div>
    </div>
  </div>
</div>

<!-- å¼•å…¥ ECharts -->
<script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/echarts-wordcloud@2.1.0/dist/echarts-wordcloud.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function () {
  const personCountChart = echarts.init(document.getElementById('personCountChart'));
  const problemTypeChart = echarts.init(document.getElementById('problemTypeChart'));
  const projectDisqualifiedChart = echarts.init(document.getElementById('projectDisqualifiedChart'));
  const wordCloudChart = echarts.init(document.getElementById('wordCloudChart'));
  const keyPersonnelTrendChart = echarts.init(document.getElementById('keyPersonnelTrendChart'));

  // æ›´æ–°é¡µé¢æ—¥æœŸèŒƒå›´æ˜¾ç¤º
  function updatePageDateRange() {
    const startDate = document.getElementById('startDate')?.value;
    const endDate = document.getElementById('endDate')?.value;
    const dateRangeEl = document.getElementById('pageDateRange');

    if (!dateRangeEl) return;

    if (startDate || endDate) {
      const start = startDate || 'èµ·å§‹';
      const end = endDate || 'å½“å‰';
      dateRangeEl.textContent = `${start} è‡³ ${end}`;
      dateRangeEl.style.display = 'inline-block';
    } else {
      dateRangeEl.textContent = 'å…¨éƒ¨æ•°æ®';
      dateRangeEl.style.display = 'inline-block';
    }
  }

  function fetchAndRenderChart() {
    const name = document.getElementById('nameFilter').value;
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    const qualified = document.getElementById('qualifiedFilter').value;

    // æ›´æ–°é¡µé¢æ—¥æœŸèŒƒå›´æ˜¾ç¤º
    updatePageDateRange();

    const params = new URLSearchParams();
    if (name) params.append('name', name);
    if (startDate) params.append('start_date', startDate);
    if (endDate) params.append('end_date', endDate);
    if (qualified) params.append('qualified', qualified);

    const apiUrl = `{{ url_for('training.api_data') }}?${params.toString()}`;

    [personCountChart, problemTypeChart, projectDisqualifiedChart, wordCloudChart, keyPersonnelTrendChart].forEach(chart => chart.showLoading());

    fetch(apiUrl)
      .then(response => response.json())
      .then(data => {
        [personCountChart, problemTypeChart, projectDisqualifiedChart, wordCloudChart, keyPersonnelTrendChart].forEach(chart => chart.hideLoading());

        updateKpis(data);
        renderPersonCountChart(data);
        renderProblemTypeChart(data);
        renderProjectDisqualifiedChart(data);
        renderWordCloudChart(data);
        renderTeamRank(data);
        renderKeyPersonnelTrend(data);
      })
      .catch(error => {
        [personCountChart, problemTypeChart, projectDisqualifiedChart, wordCloudChart, keyPersonnelTrendChart].forEach(chart => {
          try { chart.hideLoading(); } catch(e) {}
        });
        console.error('Error fetching chart data:', error);
      });
  }

  function updateKpis(data) {
    document.getElementById('kpi-total-count').textContent = data.length;
    const disqualifiedCount = data.filter(r => r.is_qualified === 0).length;
    document.getElementById('kpi-disqualified-count').textContent = disqualifiedCount;
  }

  function renderPersonCountChart(data) {
    const personCount = {};
    data.forEach(record => {
      personCount[record.name] = (personCount[record.name] || 0) + 1;
    });
    const sortedData = Object.entries(personCount).sort((a, b) => b[1] - a[1]);
    const names = sortedData.map(item => item[0]);
    const counts = sortedData.map(item => item[1]);

    const option = {
      title: { text: 'äººå‘˜å®æ“æ¬¡æ•°ç»Ÿè®¡', left: 'center' },
      tooltip: { trigger: 'axis', axisPointer: { type: 'shadow' } },
      grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
      xAxis: { type: 'category', data: names, axisLabel: { interval: 0, rotate: 30 } },
      yAxis: { type: 'value', name: 'æ¬¡æ•°' },
      series: [{
        name: 'å®æ“æ¬¡æ•°', type: 'bar', data: counts, barWidth: '60%',
        label: { show: true, position: 'top' }
      }],
      dataZoom: [{ type: 'inside' }, { type: 'slider' }]
    };
    personCountChart.setOption(option);
  }

  function renderProblemTypeChart(data) {
    // ç»Ÿè®¡æ‰€æœ‰è®°å½•çš„é—®é¢˜ç±»å‹ï¼ˆåŒ…æ‹¬åˆæ ¼å’Œä¸åˆæ ¼ï¼‰
    const problemCount = {};
    const qualifiedCount = {}; // è®°å½•æ¯ç§ç±»å‹çš„åˆæ ¼æ•°

    data.forEach(record => {
      const type = record.problem_type || 'æ— é—®é¢˜';
      problemCount[type] = (problemCount[type] || 0) + 1;

      if (record.is_qualified === 1) {
        qualifiedCount[type] = (qualifiedCount[type] || 0) + 1;
      }
    });

    // è½¬æ¢ä¸ºå›¾è¡¨æ•°æ®ï¼Œå¹¶æ·»åŠ åˆæ ¼ç‡ä¿¡æ¯
    const chartData = Object.entries(problemCount).map(([name, value]) => {
      const qualified = qualifiedCount[name] || 0;
      const qualifiedRate = ((qualified / value) * 100).toFixed(1);
      return {
        name: name,
        value: value,
        qualifiedRate: qualifiedRate,
        qualified: qualified
      };
    });

    const option = {
      title: { text: 'é—®é¢˜ç±»å‹åˆ†å¸ƒï¼ˆå…¨éƒ¨è®°å½•ï¼‰', left: 'center' },
      tooltip: {
        trigger: 'item',
        formatter: function(params) {
          return `${params.seriesName}<br/>${params.name}: ${params.value}æ¬¡ (${params.percent}%)<br/>åˆæ ¼: ${params.data.qualified}æ¬¡ (${params.data.qualifiedRate}%)`;
        }
      },
      legend: { orient: 'vertical', left: 'left', top: '10%', type: 'scroll' },
      series: [{
        name: 'é—®é¢˜ç±»å‹',
        type: 'pie',
        radius: '65%',
        center: ['50%', '60%'],
        data: chartData,
        emphasis: {
          itemStyle: { shadowBlur: 10, shadowOffsetX: 0, shadowColor: 'rgba(0, 0, 0, 0.5)' }
        },
        label: {
          formatter: '{b}\n{c}æ¬¡ ({d}%)'
        }
      }]
    };
    problemTypeChart.setOption(option);
  }

  function renderProjectDisqualifiedChart(data) {
    const disqualifiedData = data.filter(r => r.is_qualified === 0);
    const projectCount = {};
    disqualifiedData.forEach(record => {
      const project = record.project_name || 'æœªåˆ†ç±»';
      projectCount[project] = (projectCount[project] || 0) + 1;
    });
    const sortedData = Object.entries(projectCount).sort((a, b) => a[1] - b[1]);
    const projects = sortedData.map(item => item[0]);
    const counts = sortedData.map(item => item[1]);

    const option = {
      title: { text: 'å„ä¸ªå®æ“é¡¹ç›®å¤±æ ¼æ¬¡æ•°ç»Ÿè®¡', left: 'center' },
      tooltip: { trigger: 'axis', axisPointer: { type: 'shadow' } },
      grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
      xAxis: { type: 'value', boundaryGap: [0, 0.01] },
      yAxis: { type: 'category', data: projects },
      series: [{
        name: 'å¤±æ ¼æ¬¡æ•°',
        type: 'bar',
        data: counts,
        label: { show: true, position: 'right' }
      }]
    };
    projectDisqualifiedChart.setOption(option);
  }

  function renderWordCloudChart(data) {
    const disqualifiedData = data.filter(r => r.is_qualified === 0 && r.specific_problem && r.specific_problem.trim() !== 'æ— ');
    const text = disqualifiedData.map(r => r.specific_problem).join(' ');

    const wordCounts = {};
    const words = text.split(/[;ï¼›,ï¼Œ.ã€‚\s\d+\.ã€]+/g);

    words.forEach(word => {
        const w = word.trim();
        if (w && w.length > 1 && !['çš„', 'äº†', 'æœª', 'æˆ–', 'å’Œ', 'ä¸'].includes(w)) {
            wordCounts[w] = (wordCounts[w] || 0) + 1;
        }
    });

    const chartData = Object.entries(wordCounts).map(([name, value]) => ({ name, value }));

    const option = {
        title: {
            text: 'å…·ä½“å®æ“é—®é¢˜è¯äº‘å›¾',
            left: 'center'
        },
        tooltip: { show: true },
        series: [{
            type: 'wordCloud',
            shape: 'circle',
            left: 'center',
            top: 'center',
            width: '90%',
            height: '90%',
            sizeRange: [12, 50],
            rotationRange: [-90, 90],
            rotationStep: 45,
            gridSize: 8,
            drawOutOfBound: false,
            textStyle: {
                color: function () {
                    return 'rgb(' + [
                        Math.round(Math.random() * 160),
                        Math.round(Math.random() * 160),
                        Math.round(Math.random() * 160)
                    ].join(',') + ')';
                }
            },
            emphasis: {
                focus: 'self',
                textStyle: { shadowBlur: 10, shadowColor: '#333' }
            },
            data: chartData
        }]
    };
    wordCloudChart.setOption(option);
  }

  function renderTeamRank(data) {
    const rankListEl = document.getElementById('teamRankList');
    if (!rankListEl) return;

    // ç»Ÿè®¡å„ç­ç»„çš„æ•°æ®
    const teamStats = {};
    data.forEach(record => {
        const team = record.team_name || 'æœªåˆ†é…ç­ç»„';
        if (!teamStats[team]) {
            teamStats[team] = {
                total: 0,
                qualified: 0,
                totalTime: 0,
                timeCount: 0
            };
        }

        teamStats[team].total++;
        if (record.is_qualified === 1) {
            teamStats[team].qualified++;
        }

        // å¤„ç†è€—æ—¶ï¼ˆå‡è®¾æ ¼å¼ä¸º "5åˆ†é’Ÿ" æˆ– "1.5å°æ—¶"ï¼‰
        if (record.time_spent) {
            const timeStr = record.time_spent.toString();
            let minutes = 0;

            if (timeStr.includes('å°æ—¶')) {
                const hours = parseFloat(timeStr);
                if (!isNaN(hours)) minutes = hours * 60;
            } else if (timeStr.includes('åˆ†é’Ÿ')) {
                minutes = parseFloat(timeStr);
            } else {
                // å°è¯•ç›´æ¥è§£æä¸ºæ•°å­—ï¼ˆåˆ†é’Ÿï¼‰
                const parsed = parseFloat(timeStr);
                if (!isNaN(parsed)) minutes = parsed;
            }

            if (minutes > 0) {
                teamStats[team].totalTime += minutes;
                teamStats[team].timeCount++;
            }
        }
    });

    // è®¡ç®—è¾¾æ ‡ç‡å’Œå¹³å‡è€—æ—¶
    const teamData = Object.entries(teamStats).map(([name, stats]) => {
        const qualifiedRate = stats.total > 0 ? (stats.qualified / stats.total * 100) : 0;
        const avgTime = stats.timeCount > 0 ? (stats.totalTime / stats.timeCount) : 0;

        return {
            name: name,
            total: stats.total,
            qualified: stats.qualified,
            qualifiedRate: qualifiedRate,
            avgTime: avgTime
        };
    });

    // æŒ‰è¾¾æ ‡ç‡æ’åºï¼ˆè¾¾æ ‡ç‡ç›¸åŒæ—¶æŒ‰å¹³å‡è€—æ—¶å‡åºï¼‰
    const sortedTeams = teamData.sort((a, b) => {
        if (Math.abs(a.qualifiedRate - b.qualifiedRate) > 0.1) {
            return b.qualifiedRate - a.qualifiedRate;
        }
        // è¾¾æ ‡ç‡æ¥è¿‘æ—¶ï¼Œè€—æ—¶è¶ŠçŸ­è¶Šå¥½
        if (a.avgTime > 0 && b.avgTime > 0) {
            return a.avgTime - b.avgTime;
        }
        return b.total - a.total;
    });

    if (sortedTeams.length === 0) {
        rankListEl.innerHTML = '<p class="text-muted text-center mt-4">æ— ç­ç»„æ•°æ®</p>';
        return;
    }

    const rankHtml = sortedTeams.map((team, index) => {
        let rankBadge = '';
        let rankColor = '';

        if (index === 0) {
            rankBadge = '<span class="badge rounded-pill bg-warning text-dark">ğŸ¥‡</span>';
            rankColor = 'border-warning';
        } else if (index === 1) {
            rankBadge = '<span class="badge rounded-pill bg-secondary text-white">ğŸ¥ˆ</span>';
            rankColor = 'border-secondary';
        } else if (index === 2) {
            rankBadge = '<span class="badge rounded-pill text-white" style="background-color: #cd7f32;">ğŸ¥‰</span>';
            rankColor = 'border-secondary';
        } else {
            rankBadge = `<span class="badge rounded-pill bg-light text-dark">${index + 1}</span>`;
        }

        const qualifiedRateColor = team.qualifiedRate >= 90 ? 'success' : team.qualifiedRate >= 70 ? 'warning' : 'danger';
        const avgTimeDisplay = team.avgTime > 0 ? `${team.avgTime.toFixed(1)}åˆ†é’Ÿ` : '--';

        return `
            <div class="card mb-3 ${rankColor}" style="border-left-width: 3px;">
                <div class="card-body p-2">
                    <div class="d-flex justify-content-between align-items-start mb-2">
                        <div class="d-flex align-items-center">
                            ${rankBadge}
                            <span class="ms-2 fw-bold">${team.name}</span>
                        </div>
                        <span class="badge bg-light text-dark">${team.total}æ¬¡</span>
                    </div>
                    <div class="row g-2 small">
                        <div class="col-6">
                            <div class="text-muted">è¾¾æ ‡ç‡</div>
                            <div class="d-flex align-items-center">
                                <span class="badge bg-${qualifiedRateColor} me-1">${team.qualifiedRate.toFixed(1)}%</span>
                                <small class="text-muted">${team.qualified}/${team.total}</small>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="text-muted">å¹³å‡è€—æ—¶</div>
                            <div class="fw-bold text-primary">${avgTimeDisplay}</div>
                        </div>
                    </div>
                </div>
            </div>`;
    }).join('');

    rankListEl.innerHTML = rankHtml;
  }

  function renderKeyPersonnelTrend(data) {
    // 1. è®¡ç®—æ¯ä¸ªäººå‘˜çš„å¹³å‡åˆ†
    const personScores = {};
    data.forEach(record => {
      const name = record.name || 'æœªçŸ¥';
      const score = record.score || 0;

      if (!personScores[name]) {
        personScores[name] = { total: 0, count: 0, records: [] };
      }

      personScores[name].total += score;
      personScores[name].count++;
      personScores[name].records.push({
        date: record.training_date,
        score: score
      });
    });

    // 2. è®¡ç®—å¹³å‡åˆ†å¹¶æ’åº
    const personAvgScores = Object.entries(personScores).map(([name, stats]) => ({
      name: name,
      avgScore: stats.count > 0 ? stats.total / stats.count : 0,
      records: stats.records
    }));

    // æŒ‰å¹³å‡åˆ†å‡åºæ’åºï¼Œå–æœ€ä½çš„5äºº
    const bottom5 = personAvgScores.sort((a, b) => a.avgScore - b.avgScore).slice(0, 5);

    if (bottom5.length === 0) {
      const option = {
        title: { text: 'é‡ç‚¹äººå‘˜æˆç»©è¶‹åŠ¿ï¼ˆå¹³å‡åˆ†æœ€ä½Top 5ï¼‰', left: 'center' },
        graphic: {
          type: 'text',
          left: 'center',
          top: 'middle',
          style: { text: 'æš‚æ— æ•°æ®', fontSize: 16, fill: '#999' }
        }
      };
      keyPersonnelTrendChart.setOption(option);
      return;
    }

    // 3. å‡†å¤‡æ—¶é—´è½´æ•°æ®ï¼ˆæ‰€æœ‰æ—¥æœŸå»é‡å¹¶æ’åºï¼‰
    const allDates = new Set();
    bottom5.forEach(person => {
      person.records.forEach(record => {
        allDates.add(record.date);
      });
    });
    const sortedDates = Array.from(allDates).sort();

    // 4. ä¸ºæ¯ä¸ªäººå‘˜å‡†å¤‡å®Œæ•´çš„è¶‹åŠ¿æ•°æ®
    const series = bottom5.map((person, index) => {
      // æŒ‰æ—¥æœŸåˆ†ç»„ï¼Œè®¡ç®—å½“å¤©çš„å¹³å‡åˆ†
      const dateScoreMap = {};
      person.records.forEach(record => {
        if (!dateScoreMap[record.date]) {
          dateScoreMap[record.date] = [];
        }
        dateScoreMap[record.date].push(record.score);
      });

      // è®¡ç®—æ¯å¤©çš„å¹³å‡åˆ†
      const scoreData = sortedDates.map(date => {
        if (dateScoreMap[date]) {
          const avg = dateScoreMap[date].reduce((a, b) => a + b, 0) / dateScoreMap[date].length;
          return avg.toFixed(1);
        }
        return null; // è¯¥æ—¥æœŸæ²¡æœ‰æ•°æ®
      });

      // ç”Ÿæˆé¢œè‰²
      const colors = ['#d62728', '#ff7f0e', '#9467bd', '#8c564b', '#e377c2'];

      return {
        name: `${person.name} (å‡${person.avgScore.toFixed(1)})`,
        type: 'line',
        data: scoreData,
        smooth: true,
        connectNulls: true, // è¿æ¥ç©ºå€¼
        lineStyle: { width: 2 },
        itemStyle: { color: colors[index % colors.length] },
        emphasis: {
          focus: 'series',
          lineStyle: { width: 3 }
        },
        markLine: {
          silent: true,
          lineStyle: { type: 'dashed', color: '#999' },
          data: [{ yAxis: person.avgScore.toFixed(1), name: 'ä¸ªäººå‡çº¿' }]
        }
      };
    });

    const option = {
      title: {
        text: 'é‡ç‚¹äººå‘˜æˆç»©è¶‹åŠ¿ï¼ˆå¹³å‡åˆ†æœ€ä½Top 5ï¼‰',
        subtext: 'è¿½è¸ªåè¿›äººå‘˜è¿›æ­¥æƒ…å†µ',
        left: 'center'
      },
      tooltip: {
        trigger: 'axis',
        axisPointer: { type: 'cross' }
      },
      legend: {
        data: bottom5.map(p => `${p.name} (å‡${p.avgScore.toFixed(1)})`),
        bottom: 10,
        type: 'scroll'
      },
      grid: {
        left: '3%',
        right: '4%',
        bottom: '15%',
        containLabel: true
      },
      xAxis: {
        type: 'category',
        data: sortedDates,
        boundaryGap: false,
        axisLabel: {
          rotate: 30,
          formatter: function(value) {
            // æ ¼å¼åŒ–æ—¥æœŸæ˜¾ç¤º
            return value.substring(5); // åªæ˜¾ç¤ºæœˆ-æ—¥
          }
        }
      },
      yAxis: {
        type: 'value',
        name: 'åˆ†æ•°',
        min: 0,
        max: 100,
        axisLabel: { formatter: '{value}' }
      },
      series: series,
      dataZoom: [
        {
          type: 'inside',
          start: 0,
          end: 100
        },
        {
          type: 'slider',
          start: 0,
          end: 100,
          height: 20,
          bottom: 50
        }
      ]
    };

    keyPersonnelTrendChart.setOption(option);
  }

  // è®¾ç½®é»˜è®¤æ—¥æœŸä¸ºå½“æœˆ
  function setDefaultDates() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const firstDay = `${year}-${month}-01`;
    const lastDay = new Date(year, now.getMonth() + 1, 0).getDate();
    const lastDayStr = `${year}-${month}-${String(lastDay).padStart(2, '0')}`;

    document.getElementById('startDate').value = firstDay;
    document.getElementById('endDate').value = lastDayStr;
  }

  // é¡µé¢åŠ è½½æ—¶è®¾ç½®é»˜è®¤æ—¥æœŸå¹¶æ‰§è¡ŒæŸ¥è¯¢
  setDefaultDates();
  fetchAndRenderChart();

  // æŸ¥è¯¢æŒ‰é’®äº‹ä»¶
  document.getElementById('filterBtn').addEventListener('click', fetchAndRenderChart);

  // é‡ç½®æŒ‰é’®äº‹ä»¶
  document.getElementById('resetBtn').addEventListener('click', function() {
    setDefaultDates();
    document.getElementById('nameFilter').value = '';
    document.getElementById('qualifiedFilter').value = '';
    fetchAndRenderChart();
  });

  // ç›‘å¬çª—å£å¤§å°å˜åŒ–ï¼Œé‡ç»˜å›¾è¡¨
  window.addEventListener('resize', function() {
    personCountChart.resize();
    problemTypeChart.resize();
    projectDisqualifiedChart.resize();
    wordCloudChart.resize();
    keyPersonnelTrendChart.resize();
  });
});
</script>
{% endblock %}