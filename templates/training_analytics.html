{% extends "base.html" %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-3">
  <div>
    <h5 class="mb-0">åŸ¹è®­ç»Ÿè®¡åˆ†æ <span id="pageDateRange" class="badge bg-primary" style="font-size: 0.7em; vertical-align: middle;"></span></h5>
    <small class="text-muted">å¯è§†åŒ–åˆ†æåŸ¹è®­æ•°æ®å’Œé—®é¢˜è¶‹åŠ¿</small>
  </div>
  <div class="btn-group">
    <a href="{{ url_for('training.index') }}" class="btn btn-outline-secondary btn-sm">è¿”å›å·¥ä½œå°</a>
    <a href="{{ url_for('training.records') }}" class="btn btn-secondary btn-sm">æŸ¥çœ‹è®°å½•</a>
  </div>
</div>

<!-- ç­›é€‰åŒºåŸŸ -->
<div class="card shadow-sm mb-4">
  <div class="card-body">
    <div class="row g-3 align-items-end">
      <div class="col-md-2">
        <label for="nameFilter" class="form-label">å§“å</label>
        <input type="text" id="nameFilter" class="form-control form-control-sm">
      </div>
      {% set col_class = 'col-md-2' %}
      {% set show_quick_buttons = true %}
      {% set show_range_label = true %}
      {% include 'components/date_filter.html' %}
      <div class="col-md-2">
        <label for="qualifiedFilter" class="form-label">æ˜¯å¦åˆæ ¼</label>
        <select id="qualifiedFilter" class="form-select form-select-sm">
          <option value="">å…¨éƒ¨</option>
          <option value="1">åˆæ ¼</option>
          <option value="0">ä¸åˆæ ¼</option>
        </select>
      </div>
      <div class="col-md-2">
        <button id="filterBtn" class="btn btn-sm btn-primary w-100">
          <i class="bi bi-search"></i> æŸ¥è¯¢
        </button>
      </div>
      <div class="col-md-2">
        <button id="resetBtn" class="btn btn-sm btn-outline-secondary w-100">
          <i class="bi bi-arrow-counterclockwise"></i> é‡ç½®ä¸ºæœ¬æœˆ
        </button>
      </div>
    </div>
  </div>
</div>

<!-- KPI å¡ç‰‡ -->
<div class="row g-4 mb-4">
  <div class="col-md-6">
    <div class="card shadow-sm">
      <div class="card-body text-center">
        <h6 class="card-subtitle mb-2 text-muted">ç­›é€‰åŒºé—´å†…æ€»äººæ¬¡</h6>
        <p class="card-text fs-1 fw-bold" id="kpi-total-count">0</p>
      </div>
    </div>
  </div>
  <div class="col-md-6">
    <div class="card shadow-sm">
      <div class="card-body text-center">
        <h6 class="card-subtitle mb-2 text-muted">ç­›é€‰åŒºé—´å†…å¤±æ ¼äººæ¬¡</h6>
        <p class="card-text fs-1 fw-bold text-danger" id="kpi-disqualified-count">0</p>
      </div>
    </div>
  </div>
</div>

<!-- å¤šæ ‡ç­¾é¡µå¯¼èˆª -->
<ul class="nav nav-tabs mb-3" id="analyticsTabs" role="tablist">
  <li class="nav-item" role="presentation">
    <button class="nav-link active" id="overview-tab" data-bs-toggle="tab" data-bs-target="#overview" type="button" role="tab" aria-controls="overview" aria-selected="true">
      <i class="bi bi-bar-chart-fill"></i> æ€»è§ˆ
    </button>
  </li>
  <li class="nav-item" role="presentation">
    <button class="nav-link" id="project-tab" data-bs-toggle="tab" data-bs-target="#project" type="button" role="tab" aria-controls="project" aria-selected="false">
      <i class="bi bi-diagram-3-fill"></i> é¡¹ç›®åˆ†æ
    </button>
  </li>
  <li class="nav-item" role="presentation">
    <button class="nav-link" id="personnel-tab" data-bs-toggle="tab" data-bs-target="#personnel" type="button" role="tab" aria-controls="personnel" aria-selected="false">
      <i class="bi bi-people-fill"></i> äººå‘˜åˆ†æ
    </button>
  </li>
</ul>

<!-- æ ‡ç­¾é¡µå†…å®¹ -->
<div class="tab-content" id="analyticsTabContent">
  <!-- Tab 1: æ€»è§ˆ -->
  <div class="tab-pane fade show active" id="overview" role="tabpanel" aria-labelledby="overview-tab">
    <div class="row g-4 mb-4">
      <div class="col-xl-6 col-lg-12">
        <div class="card shadow-sm h-100">
          <div class="card-body">
            <div id="problemTypeChart" style="width: 100%; min-height: 400px; height: 50vh; max-height: 600px;"></div>
          </div>
        </div>
      </div>
      <div class="col-xl-6 col-lg-12">
        <div class="card shadow-sm h-100">
          <div class="card-body">
            <div id="projectDisqualifiedChart" style="width: 100%; min-height: 400px; height: 50vh; max-height: 600px;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Tab 2: é¡¹ç›®åˆ†æ -->
  <div class="tab-pane fade" id="project" role="tabpanel" aria-labelledby="project-tab">
    <div class="row g-4 mb-4">
      <div class="col-xl-6 col-lg-12">
        <div class="card shadow-sm h-100">
          <div class="card-body">
            <div id="projectCountChart" style="width: 100%; min-height: 400px; height: 55vh; max-height: 700px;"></div>
          </div>
        </div>
      </div>
      <div class="col-xl-6 col-lg-12">
        <div class="card shadow-sm h-100">
          <div class="card-body">
            <div id="wordCloudChart" style="width: 100%; min-height: 400px; height: 55vh; max-height: 700px;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Tab 3: äººå‘˜åˆ†æ -->
  <div class="tab-pane fade" id="personnel" role="tabpanel" aria-labelledby="personnel-tab">
    <div class="row g-4 mb-4">
      <div class="col-xl-8 col-lg-12">
        <div class="card shadow-sm h-100">
          <div class="card-body">
            <div id="personCountChart" style="width: 100%; min-height: 400px; height: 50vh; max-height: 600px;"></div>
          </div>
        </div>
      </div>
      <div class="col-xl-4 col-lg-12">
        <div class="card shadow-sm h-100">
          <div class="card-body">
            <h6 class="card-title text-center mb-3">ç­ç»„/è½¦é˜ŸPKæ¦œ</h6>
            <div id="teamRankList" style="max-height: 450px; overflow-y: auto; -webkit-overflow-scrolling: touch;">
              <!-- Ranking will be generated by JS -->
            </div>
          </div>
        </div>
      </div>
      <div class="col-12">
        <div class="card shadow-sm">
          <div class="card-body">
            <div id="keyPersonnelTrendChart" style="width: 100%; min-height: 400px; height: 50vh; max-height: 600px;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- å¼•å…¥ ECharts -->
<script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/echarts-wordcloud@2.1.0/dist/echarts-wordcloud.min.js"></script>

<!-- å¼•å…¥æ—¥æœŸç­›é€‰å™¨åº“ -->
<script src="{{ url_for('static', filename='js/date-filter.js') }}"></script>

<script>
document.addEventListener('DOMContentLoaded', function () {
  // Chart instances (initialized lazily)
  let personCountChart = null;
  let problemTypeChart = null;
  let projectDisqualifiedChart = null;
  let projectCountChart = null;
  let wordCloudChart = null;
  let keyPersonnelTrendChart = null;

  // Track which tabs have been initialized
  const tabsInitialized = {
    overview: false,
    project: false,
    personnel: false
  };

  // Store fetched data for lazy loading
  let cachedData = null;

  // Initialize charts for a specific tab
  function initializeTabCharts(tabName) {
    if (tabsInitialized[tabName]) return;

    switch(tabName) {
      case 'overview':
        problemTypeChart = echarts.init(document.getElementById('problemTypeChart'));
        projectDisqualifiedChart = echarts.init(document.getElementById('projectDisqualifiedChart'));
        if (cachedData) {
          renderProblemTypeChart(cachedData);
          renderProjectDisqualifiedChart(cachedData);
        }
        break;
      case 'project':
        projectCountChart = echarts.init(document.getElementById('projectCountChart'));
        wordCloudChart = echarts.init(document.getElementById('wordCloudChart'));
        if (cachedData) {
          renderProjectCountChart(cachedData);
          renderWordCloudChart(cachedData);
        }
        break;
      case 'personnel':
        personCountChart = echarts.init(document.getElementById('personCountChart'));
        keyPersonnelTrendChart = echarts.init(document.getElementById('keyPersonnelTrendChart'));
        if (cachedData) {
          renderPersonCountChart(cachedData);
          renderTeamRank(cachedData);
          renderKeyPersonnelTrend(cachedData);
        }
        break;
    }

    tabsInitialized[tabName] = true;
  }

  // Tab switch event listener
  const tabButtons = document.querySelectorAll('#analyticsTabs button[data-bs-toggle="tab"]');
  tabButtons.forEach(button => {
    button.addEventListener('shown.bs.tab', function (event) {
      const targetId = event.target.getAttribute('data-bs-target').substring(1);
      initializeTabCharts(targetId);

      // Resize charts when switching tabs
      if (targetId === 'overview' && problemTypeChart && projectDisqualifiedChart) {
        problemTypeChart.resize();
        projectDisqualifiedChart.resize();
      } else if (targetId === 'project' && projectCountChart && wordCloudChart) {
        projectCountChart.resize();
        wordCloudChart.resize();
      } else if (targetId === 'personnel' && personCountChart && keyPersonnelTrendChart) {
        personCountChart.resize();
        keyPersonnelTrendChart.resize();
      }
    });
  });

  // æ›´æ–°é¡µé¢æ—¥æœŸèŒƒå›´æ˜¾ç¤º
  function updatePageDateRange() {
    const startDate = document.getElementById('startDate')?.value;
    const endDate = document.getElementById('endDate')?.value;
    const dateRangeEl = document.getElementById('pageDateRange');

    if (!dateRangeEl) return;

    if (startDate || endDate) {
      const start = startDate || 'èµ·å§‹';
      const end = endDate || 'å½“å‰';
      dateRangeEl.textContent = `${start} è‡³ ${end}`;
      dateRangeEl.style.display = 'inline-block';
    } else {
      dateRangeEl.textContent = 'å…¨éƒ¨æ•°æ®';
      dateRangeEl.style.display = 'inline-block';
    }
  }

  function fetchAndRenderChart() {
    const name = document.getElementById('nameFilter').value;
    const qualified = document.getElementById('qualifiedFilter').value;

    // è·å–æ—¥æœŸå‚æ•°
    const dateParams = dateFilter ? dateFilter.getParams() : { start_date: '', end_date: '' };

    const params = new URLSearchParams();
    if (name) params.append('name', name);
    if (dateParams.start_date) params.append('start_date', dateParams.start_date);
    if (dateParams.end_date) params.append('end_date', dateParams.end_date);
    if (qualified) params.append('qualified', qualified);

    const apiUrl = `{{ url_for('training.api_data') }}?${params.toString()}`;

    // Show loading for initialized charts only
    if (problemTypeChart) problemTypeChart.showLoading();
    if (projectDisqualifiedChart) projectDisqualifiedChart.showLoading();
    if (projectCountChart) projectCountChart.showLoading();
    if (wordCloudChart) wordCloudChart.showLoading();
    if (personCountChart) personCountChart.showLoading();
    if (keyPersonnelTrendChart) keyPersonnelTrendChart.showLoading();

    fetch(apiUrl)
      .then(response => response.json())
      .then(data => {
        // Hide loading for initialized charts
        if (problemTypeChart) problemTypeChart.hideLoading();
        if (projectDisqualifiedChart) projectDisqualifiedChart.hideLoading();
        if (projectCountChart) projectCountChart.hideLoading();
        if (wordCloudChart) wordCloudChart.hideLoading();
        if (personCountChart) personCountChart.hideLoading();
        if (keyPersonnelTrendChart) keyPersonnelTrendChart.hideLoading();

        // Cache data for lazy loading
        cachedData = data;

        // Update KPIs (always visible)
        updateKpis(data);

        // Render charts for currently active tab
        if (tabsInitialized.overview) {
          renderProblemTypeChart(data);
          renderProjectDisqualifiedChart(data);
        }
        if (tabsInitialized.project) {
          renderProjectCountChart(data);
          renderWordCloudChart(data);
        }
        if (tabsInitialized.personnel) {
          renderPersonCountChart(data);
          renderTeamRank(data);
          renderKeyPersonnelTrend(data);
        }
      })
      .catch(error => {
        // Hide loading for all initialized charts
        if (problemTypeChart) try { problemTypeChart.hideLoading(); } catch(e) {}
        if (projectDisqualifiedChart) try { projectDisqualifiedChart.hideLoading(); } catch(e) {}
        if (projectCountChart) try { projectCountChart.hideLoading(); } catch(e) {}
        if (wordCloudChart) try { wordCloudChart.hideLoading(); } catch(e) {}
        if (personCountChart) try { personCountChart.hideLoading(); } catch(e) {}
        if (keyPersonnelTrendChart) try { keyPersonnelTrendChart.hideLoading(); } catch(e) {}
        console.error('Error fetching chart data:', error);
      });
  }

  function updateKpis(data) {
    document.getElementById('kpi-total-count').textContent = data.length;
    const disqualifiedCount = data.filter(r => r.is_qualified === 0).length;
    document.getElementById('kpi-disqualified-count').textContent = disqualifiedCount;
  }

  function renderPersonCountChart(data) {
    if (!personCountChart) return;

    const personCount = {};
    data.forEach(record => {
      personCount[record.name] = (personCount[record.name] || 0) + 1;
    });
    const sortedData = Object.entries(personCount).sort((a, b) => b[1] - a[1]);
    const names = sortedData.map(item => item[0]);
    const counts = sortedData.map(item => item[1]);

    const option = {
      title: { text: 'äººå‘˜å®æ“æ¬¡æ•°ç»Ÿè®¡', left: 'center' },
      tooltip: { trigger: 'axis', axisPointer: { type: 'shadow' } },
      grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
      xAxis: { type: 'category', data: names, axisLabel: { interval: 0, rotate: 30 } },
      yAxis: { type: 'value', name: 'æ¬¡æ•°' },
      series: [{
        name: 'å®æ“æ¬¡æ•°', type: 'bar', data: counts, barWidth: '60%',
        label: { show: true, position: 'top' }
      }],
      dataZoom: [{ type: 'inside' }, { type: 'slider' }]
    };
    personCountChart.setOption(option);
  }

  function renderProblemTypeChart(data) {
    if (!problemTypeChart) return;

    // ç»Ÿè®¡æ‰€æœ‰è®°å½•çš„é—®é¢˜ç±»å‹ï¼ˆåŒ…æ‹¬åˆæ ¼å’Œä¸åˆæ ¼ï¼‰
    const problemCount = {};
    const qualifiedCount = {}; // è®°å½•æ¯ç§ç±»å‹çš„åˆæ ¼æ•°

    data.forEach(record => {
      const type = record.problem_type || 'æ— é—®é¢˜';
      problemCount[type] = (problemCount[type] || 0) + 1;

      if (record.is_qualified === 1) {
        qualifiedCount[type] = (qualifiedCount[type] || 0) + 1;
      }
    });

    // è½¬æ¢ä¸ºå›¾è¡¨æ•°æ®ï¼Œå¹¶æ·»åŠ åˆæ ¼ç‡ä¿¡æ¯
    const chartData = Object.entries(problemCount).map(([name, value]) => {
      const qualified = qualifiedCount[name] || 0;
      const qualifiedRate = ((qualified / value) * 100).toFixed(1);
      return {
        name: name,
        value: value,
        qualifiedRate: qualifiedRate,
        qualified: qualified
      };
    });

    const option = {
      title: { text: 'é—®é¢˜ç±»å‹åˆ†å¸ƒï¼ˆå…¨éƒ¨è®°å½•ï¼‰', left: 'center' },
      tooltip: {
        trigger: 'item',
        formatter: function(params) {
          return `${params.seriesName}<br/>${params.name}: ${params.value}æ¬¡ (${params.percent}%)<br/>åˆæ ¼: ${params.data.qualified}æ¬¡ (${params.data.qualifiedRate}%)`;
        }
      },
      legend: { orient: 'vertical', left: 'left', top: '10%', type: 'scroll' },
      series: [{
        name: 'é—®é¢˜ç±»å‹',
        type: 'pie',
        radius: '65%',
        center: ['50%', '60%'],
        data: chartData,
        emphasis: {
          itemStyle: { shadowBlur: 10, shadowOffsetX: 0, shadowColor: 'rgba(0, 0, 0, 0.5)' }
        },
        label: {
          formatter: '{b}\n{c}æ¬¡ ({d}%)'
        }
      }]
    };
    problemTypeChart.setOption(option);
  }

  function renderProjectDisqualifiedChart(data) {
    if (!projectDisqualifiedChart) return;

    const disqualifiedData = data.filter(r => r.is_qualified === 0);
    const projectCount = {};
    disqualifiedData.forEach(record => {
      const project = record.project_name || 'æœªåˆ†ç±»';
      projectCount[project] = (projectCount[project] || 0) + 1;
    });
    const sortedData = Object.entries(projectCount).sort((a, b) => a[1] - b[1]);
    const projects = sortedData.map(item => item[0]);
    const counts = sortedData.map(item => item[1]);

    const option = {
      title: { text: 'å„ä¸ªå®æ“é¡¹ç›®å¤±æ ¼æ¬¡æ•°ç»Ÿè®¡', left: 'center' },
      tooltip: { trigger: 'axis', axisPointer: { type: 'shadow' } },
      grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
      xAxis: { type: 'value', boundaryGap: [0, 0.01] },
      yAxis: { type: 'category', data: projects },
      series: [{
        name: 'å¤±æ ¼æ¬¡æ•°',
        type: 'bar',
        data: counts,
        label: { show: true, position: 'right' }
      }]
    };
    projectDisqualifiedChart.setOption(option);
  }

  function renderProjectCountChart(data) {
    if (!projectCountChart) return;

    // ç»Ÿè®¡æ‰€æœ‰é¡¹ç›®çš„æ€»æ¬¡æ•°ï¼ˆåŒ…æ‹¬åˆæ ¼å’Œä¸åˆæ ¼ï¼‰
    const projectCount = {};
    data.forEach(record => {
      const project = record.project_name || 'æœªåˆ†ç±»';
      projectCount[project] = (projectCount[project] || 0) + 1;
    });

    // æŒ‰æ¬¡æ•°é™åºæ’åˆ—ï¼Œåªå–å‰20ä¸ª
    const sortedData = Object.entries(projectCount).sort((a, b) => b[1] - a[1]).slice(0, 20);
    const projects = sortedData.map(item => item[0]);
    const counts = sortedData.map(item => item[1]);

    // Top 10 é«˜äº®å¤„ç†
    const itemStyleData = counts.map((count, index) => {
      if (index < 10) {
        // Top 10 ä½¿ç”¨æ¸å˜è‰²é«˜äº®
        return {
          value: count,
          itemStyle: {
            color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [
              { offset: 0, color: '#4A90E2' },
              { offset: 1, color: '#67B7DC' }
            ])
          }
        };
      } else {
        // å…¶ä½™å¼±åŒ–
        return {
          value: count,
          itemStyle: {
            color: '#95a5a6'
          }
        };
      }
    });

    const option = {
      title: {
        text: 'å„å®æ“é¡¹ç›®æ€»æ¬¡æ•°ç»Ÿè®¡ (Top 20)',
        subtext: 'Top 10 è“è‰²é«˜äº® | é™åºæ’åˆ—',
        left: 'center'
      },
      tooltip: {
        trigger: 'axis',
        axisPointer: { type: 'shadow' },
        formatter: function(params) {
          const param = params[0];
          const rank = sortedData.findIndex(item => item[0] === param.name) + 1;
          return `æ’å #${rank}<br/>${param.name}: ${param.value}æ¬¡`;
        }
      },
      grid: {
        left: '3%',
        right: '4%',
        bottom: '3%',
        top: '15%',
        containLabel: true
      },
      xAxis: {
        type: 'value',
        boundaryGap: [0, 0.01],
        name: 'æ¬¡æ•°',
        nameLocation: 'end',
        nameTextStyle: {
          padding: [0, 0, 0, 10]
        }
      },
      yAxis: {
        type: 'category',
        data: projects,
        axisLabel: {
          formatter: function(value) {
            // é•¿æ–‡æœ¬æˆªæ–­å¹¶æ˜¾ç¤ºçœç•¥å·
            return value.length > 18 ? value.substring(0, 18) + '...' : value;
          }
        }
      },
      series: [{
        name: 'åŸ¹è®­æ¬¡æ•°',
        type: 'bar',
        data: itemStyleData,
        barWidth: '60%',
        label: {
          show: true,
          position: 'right',
          formatter: '{c}æ¬¡',
          fontSize: 11
        },
        emphasis: {
          focus: 'self',
          itemStyle: {
            shadowBlur: 10,
            shadowColor: 'rgba(0, 0, 0, 0.3)'
          }
        }
      }],
      dataZoom: projects.length > 15 ? [
        {
          type: 'inside',
          yAxisIndex: 0,
          start: 0,
          end: 100
        },
        {
          type: 'slider',
          yAxisIndex: 0,
          start: 0,
          end: 100,
          width: 12,
          right: 5
        }
      ] : []
    };
    projectCountChart.setOption(option);
  }

  function renderWordCloudChart(data) {
    if (!wordCloudChart) return;

    const disqualifiedData = data.filter(r => r.is_qualified === 0 && r.specific_problem && r.specific_problem.trim() !== 'æ— ');
    const text = disqualifiedData.map(r => r.specific_problem).join(' ');

    const wordCounts = {};
    const words = text.split(/[;ï¼›,ï¼Œ.ã€‚\s\d+\.ã€]+/g);

    words.forEach(word => {
        const w = word.trim();
        if (w && w.length > 1 && !['çš„', 'äº†', 'æœª', 'æˆ–', 'å’Œ', 'ä¸'].includes(w)) {
            wordCounts[w] = (wordCounts[w] || 0) + 1;
        }
    });

    const chartData = Object.entries(wordCounts).map(([name, value]) => ({ name, value }));

    const option = {
        title: {
            text: 'å…·ä½“å®æ“é—®é¢˜è¯äº‘å›¾',
            left: 'center'
        },
        tooltip: { show: true },
        series: [{
            type: 'wordCloud',
            shape: 'circle',
            left: 'center',
            top: 'center',
            width: '90%',
            height: '90%',
            sizeRange: [12, 50],
            rotationRange: [-90, 90],
            rotationStep: 45,
            gridSize: 8,
            drawOutOfBound: false,
            textStyle: {
                color: function () {
                    return 'rgb(' + [
                        Math.round(Math.random() * 160),
                        Math.round(Math.random() * 160),
                        Math.round(Math.random() * 160)
                    ].join(',') + ')';
                }
            },
            emphasis: {
                focus: 'self',
                textStyle: { shadowBlur: 10, shadowColor: '#333' }
            },
            data: chartData
        }]
    };
    wordCloudChart.setOption(option);
  }

  function renderTeamRank(data) {
    const rankListEl = document.getElementById('teamRankList');
    if (!rankListEl) return;

    // ç»Ÿè®¡å„ç­ç»„çš„æ•°æ®
    const teamStats = {};
    data.forEach(record => {
        const team = record.team_name || 'æœªåˆ†é…ç­ç»„';
        if (!teamStats[team]) {
            teamStats[team] = {
                total: 0,
                qualified: 0,
                totalTime: 0,
                timeCount: 0
            };
        }

        teamStats[team].total++;
        if (record.is_qualified === 1) {
            teamStats[team].qualified++;
        }

        // å¤„ç†è€—æ—¶ï¼ˆå‡è®¾æ ¼å¼ä¸º "5åˆ†é’Ÿ" æˆ– "1.5å°æ—¶"ï¼‰
        if (record.time_spent) {
            const timeStr = record.time_spent.toString();
            let minutes = 0;

            if (timeStr.includes('å°æ—¶')) {
                const hours = parseFloat(timeStr);
                if (!isNaN(hours)) minutes = hours * 60;
            } else if (timeStr.includes('åˆ†é’Ÿ')) {
                minutes = parseFloat(timeStr);
            } else {
                // å°è¯•ç›´æ¥è§£æä¸ºæ•°å­—ï¼ˆåˆ†é’Ÿï¼‰
                const parsed = parseFloat(timeStr);
                if (!isNaN(parsed)) minutes = parsed;
            }

            if (minutes > 0) {
                teamStats[team].totalTime += minutes;
                teamStats[team].timeCount++;
            }
        }
    });

    // è®¡ç®—è¾¾æ ‡ç‡å’Œå¹³å‡è€—æ—¶
    const teamData = Object.entries(teamStats).map(([name, stats]) => {
        const qualifiedRate = stats.total > 0 ? (stats.qualified / stats.total * 100) : 0;
        const avgTime = stats.timeCount > 0 ? (stats.totalTime / stats.timeCount) : 0;

        return {
            name: name,
            total: stats.total,
            qualified: stats.qualified,
            qualifiedRate: qualifiedRate,
            avgTime: avgTime
        };
    });

    // æŒ‰è¾¾æ ‡ç‡æ’åºï¼ˆè¾¾æ ‡ç‡ç›¸åŒæ—¶æŒ‰å¹³å‡è€—æ—¶å‡åºï¼‰
    const sortedTeams = teamData.sort((a, b) => {
        if (Math.abs(a.qualifiedRate - b.qualifiedRate) > 0.1) {
            return b.qualifiedRate - a.qualifiedRate;
        }
        // è¾¾æ ‡ç‡æ¥è¿‘æ—¶ï¼Œè€—æ—¶è¶ŠçŸ­è¶Šå¥½
        if (a.avgTime > 0 && b.avgTime > 0) {
            return a.avgTime - b.avgTime;
        }
        return b.total - a.total;
    });

    if (sortedTeams.length === 0) {
        rankListEl.innerHTML = '<p class="text-muted text-center mt-4">æ— ç­ç»„æ•°æ®</p>';
        return;
    }

    const rankHtml = sortedTeams.map((team, index) => {
        let rankBadge = '';
        let rankColor = '';

        if (index === 0) {
            rankBadge = '<span class="badge rounded-pill bg-warning text-dark">ğŸ¥‡</span>';
            rankColor = 'border-warning';
        } else if (index === 1) {
            rankBadge = '<span class="badge rounded-pill bg-secondary text-white">ğŸ¥ˆ</span>';
            rankColor = 'border-secondary';
        } else if (index === 2) {
            rankBadge = '<span class="badge rounded-pill text-white" style="background-color: #cd7f32;">ğŸ¥‰</span>';
            rankColor = 'border-secondary';
        } else {
            rankBadge = `<span class="badge rounded-pill bg-light text-dark">${index + 1}</span>`;
        }

        const qualifiedRateColor = team.qualifiedRate >= 90 ? 'success' : team.qualifiedRate >= 70 ? 'warning' : 'danger';
        const avgTimeDisplay = team.avgTime > 0 ? `${team.avgTime.toFixed(1)}åˆ†é’Ÿ` : '--';

        return `
            <div class="card mb-3 ${rankColor}" style="border-left-width: 3px;">
                <div class="card-body p-2">
                    <div class="d-flex justify-content-between align-items-start mb-2">
                        <div class="d-flex align-items-center">
                            ${rankBadge}
                            <span class="ms-2 fw-bold">${team.name}</span>
                        </div>
                        <span class="badge bg-light text-dark">${team.total}æ¬¡</span>
                    </div>
                    <div class="row g-2 small">
                        <div class="col-6">
                            <div class="text-muted">è¾¾æ ‡ç‡</div>
                            <div class="d-flex align-items-center">
                                <span class="badge bg-${qualifiedRateColor} me-1">${team.qualifiedRate.toFixed(1)}%</span>
                                <small class="text-muted">${team.qualified}/${team.total}</small>
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="text-muted">å¹³å‡è€—æ—¶</div>
                            <div class="fw-bold text-primary">${avgTimeDisplay}</div>
                        </div>
                    </div>
                </div>
            </div>`;
    }).join('');

    rankListEl.innerHTML = rankHtml;
  }

  function renderKeyPersonnelTrend(data) {
    if (!keyPersonnelTrendChart) return;

    // 1. è®¡ç®—æ¯ä¸ªäººå‘˜çš„å¹³å‡åˆ†
    const personScores = {};
    data.forEach(record => {
      const name = record.name || 'æœªçŸ¥';
      const score = record.score || 0;

      if (!personScores[name]) {
        personScores[name] = { total: 0, count: 0, records: [] };
      }

      personScores[name].total += score;
      personScores[name].count++;
      personScores[name].records.push({
        date: record.training_date,
        score: score
      });
    });

    // 2. è®¡ç®—å¹³å‡åˆ†å¹¶æ’åº
    const personAvgScores = Object.entries(personScores).map(([name, stats]) => ({
      name: name,
      avgScore: stats.count > 0 ? stats.total / stats.count : 0,
      records: stats.records
    }));

    // æŒ‰å¹³å‡åˆ†å‡åºæ’åº,å–æœ€ä½çš„5äºº
    const bottom5 = personAvgScores.sort((a, b) => a.avgScore - b.avgScore).slice(0, 5);

    if (bottom5.length === 0) {
      const option = {
        title: { text: 'é‡ç‚¹äººå‘˜æˆç»©è¶‹åŠ¿ï¼ˆå¹³å‡åˆ†æœ€ä½Top 5ï¼‰', left: 'center' },
        graphic: {
          type: 'text',
          left: 'center',
          top: 'middle',
          style: { text: 'æš‚æ— æ•°æ®', fontSize: 16, fill: '#999' }
        }
      };
      keyPersonnelTrendChart.setOption(option);
      return;
    }

    // 3. å‡†å¤‡æ—¶é—´è½´æ•°æ®ï¼ˆæ‰€æœ‰æ—¥æœŸå»é‡å¹¶æ’åºï¼‰
    const allDates = new Set();
    bottom5.forEach(person => {
      person.records.forEach(record => {
        allDates.add(record.date);
      });
    });
    const sortedDates = Array.from(allDates).sort();

    // 4. ä¸ºæ¯ä¸ªäººå‘˜å‡†å¤‡å®Œæ•´çš„è¶‹åŠ¿æ•°æ®
    const series = bottom5.map((person, index) => {
      // æŒ‰æ—¥æœŸåˆ†ç»„ï¼Œè®¡ç®—å½“å¤©çš„å¹³å‡åˆ†
      const dateScoreMap = {};
      person.records.forEach(record => {
        if (!dateScoreMap[record.date]) {
          dateScoreMap[record.date] = [];
        }
        dateScoreMap[record.date].push(record.score);
      });

      // è®¡ç®—æ¯å¤©çš„å¹³å‡åˆ†
      const scoreData = sortedDates.map(date => {
        if (dateScoreMap[date]) {
          const avg = dateScoreMap[date].reduce((a, b) => a + b, 0) / dateScoreMap[date].length;
          return avg.toFixed(1);
        }
        return null; // è¯¥æ—¥æœŸæ²¡æœ‰æ•°æ®
      });

      // ç”Ÿæˆé¢œè‰²
      const colors = ['#d62728', '#ff7f0e', '#9467bd', '#8c564b', '#e377c2'];

      return {
        name: `${person.name} (å‡${person.avgScore.toFixed(1)})`,
        type: 'line',
        data: scoreData,
        smooth: true,
        connectNulls: true, // è¿æ¥ç©ºå€¼
        lineStyle: { width: 2 },
        itemStyle: { color: colors[index % colors.length] },
        emphasis: {
          focus: 'series',
          lineStyle: { width: 3 }
        },
        markLine: {
          silent: true,
          lineStyle: { type: 'dashed', color: '#999' },
          data: [{ yAxis: person.avgScore.toFixed(1), name: 'ä¸ªäººå‡çº¿' }]
        }
      };
    });

    const option = {
      title: {
        text: 'é‡ç‚¹äººå‘˜æˆç»©è¶‹åŠ¿ï¼ˆå¹³å‡åˆ†æœ€ä½Top 5ï¼‰',
        subtext: 'è¿½è¸ªåè¿›äººå‘˜è¿›æ­¥æƒ…å†µ',
        left: 'center'
      },
      tooltip: {
        trigger: 'axis',
        axisPointer: { type: 'cross' }
      },
      legend: {
        data: bottom5.map(p => `${p.name} (å‡${p.avgScore.toFixed(1)})`),
        bottom: 10,
        type: 'scroll'
      },
      grid: {
        left: '3%',
        right: '4%',
        bottom: '15%',
        containLabel: true
      },
      xAxis: {
        type: 'category',
        data: sortedDates,
        boundaryGap: false,
        axisLabel: {
          rotate: 30,
          formatter: function(value) {
            // æ ¼å¼åŒ–æ—¥æœŸæ˜¾ç¤º
            return value.substring(5); // åªæ˜¾ç¤ºæœˆ-æ—¥
          }
        }
      },
      yAxis: {
        type: 'value',
        name: 'åˆ†æ•°',
        min: 0,
        max: 100,
        axisLabel: { formatter: '{value}' }
      },
      series: series,
      dataZoom: [
        {
          type: 'inside',
          start: 0,
          end: 100
        },
        {
          type: 'slider',
          start: 0,
          end: 100,
          height: 20,
          bottom: 50
        }
      ]
    };

    keyPersonnelTrendChart.setOption(option);
  }

  // åˆå§‹åŒ–æ—¥æœŸç­›é€‰å™¨
  let dateFilter = null;

  // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–ç¬¬ä¸€ä¸ªæ ‡ç­¾é¡µå¹¶æ‰§è¡ŒæŸ¥è¯¢
  initializeTabCharts('overview'); // Initialize first tab

  // åˆå§‹åŒ–DateFilterHelper
  dateFilter = new DateFilterHelper({
    defaultRange: 'current_month',
    onDateChange: fetchAndRenderChart,
    showQuickButtons: true,
    validateDates: true,
    updateCallback: updatePageDateRange
  });

  fetchAndRenderChart();

  // æŸ¥è¯¢æŒ‰é’®äº‹ä»¶
  document.getElementById('filterBtn').addEventListener('click', fetchAndRenderChart);

  // é‡ç½®æŒ‰é’®äº‹ä»¶
  document.getElementById('resetBtn').addEventListener('click', function() {
    if (dateFilter) {
      dateFilter.setDefaultDates('current_month');
    }
    document.getElementById('nameFilter').value = '';
    document.getElementById('qualifiedFilter').value = '';
    fetchAndRenderChart();
  });

  // ç›‘å¬çª—å£å¤§å°å˜åŒ–ï¼Œé‡ç»˜å›¾è¡¨
  window.addEventListener('resize', function() {
    if (personCountChart) personCountChart.resize();
    if (problemTypeChart) problemTypeChart.resize();
    if (projectDisqualifiedChart) projectDisqualifiedChart.resize();
    if (projectCountChart) projectCountChart.resize();
    if (wordCloudChart) wordCloudChart.resize();
    if (keyPersonnelTrendChart) keyPersonnelTrendChart.resize();
  });
});
</script>
{% endblock %}
